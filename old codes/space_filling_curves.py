# -*- coding: utf-8 -*-
"""cgs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16vS3PHDEkC1wRxBRl4bPifLvQ8DEOt_v

#Aayush Gohil and Swadhin Agrawal
###*aayushgohil3433@gmail.com* *swadhin20@iiserb.ac.in*
"""

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

def plot_main_figure(height,width,inner_grid_height,inner_grid_width):
    x_scalar,y_scalar = 0,0
    x,y = [0],[0]

    x_scalar,y_scalar = width,0
    x,y = np.append(x,x_scalar),np.append(y,y_scalar)

    # print(x,y)
    x_scalar,y_scalar = x_scalar,y_scalar + height-inner_grid_height
    x,y = np.append(x,x_scalar),np.append(y,y_scalar)
    # print(x,y)

    x_scalar,y_scalar = x_scalar + width,y_scalar
    x,y = np.append(x,x_scalar),np.append(y,y_scalar)
    # print(x,y)

    x_scalar,y_scalar = x_scalar,y_scalar + height
    x,y = np.append(x,x_scalar),np.append(y,y_scalar)
    # print(x,y)

    x_scalar,y_scalar = x_scalar - width,y_scalar
    x,y = np.append(x,x_scalar),np.append(y,y_scalar)
    # print(x,y)

    x_scalar,y_scalar = x_scalar,y_scalar - height + inner_grid_height
    x,y = np.append(x,x_scalar),np.append(y,y_scalar)
    # print(x,y)

    x_scalar,y_scalar = x_scalar-width ,y_scalar
    x,y = np.append(x,x_scalar),np.append(y,y_scalar)
    # print(x,y)

    x_scalar,y_scalar = x_scalar ,y_scalar-height
    x,y = np.append(x,x_scalar),np.append(y,y_scalar)
    # print(x,y)


    plt.plot(x,y,color = 'black')

    dual_graph_vertices_1, rectangular_hilbert_curves_1 = make_grid(x[0],y[0],x[6],y[6],inner_grid_height,inner_grid_width)
    dual_graph_vertices_2, rectangular_hilbert_curves_2 = make_grid(x[2],y[2],x[4],y[4],inner_grid_height,inner_grid_width)
    return dual_graph_vertices_1, dual_graph_vertices_2, rectangular_hilbert_curves_1, rectangular_hilbert_curves_2

def make_grid(x1,y1,x2,y2,inner_grid_height,inner_grid_width):
    #assume points convention (0,0),(1,0),(1,1),(0,1)

    x_center,y_center = [],[]

    width = x2-x1
    height = y2-y1


    hor_patch = [ x1 + i*inner_grid_width for i in range((width//inner_grid_width))]
    ver_patch = [ y1 + i*inner_grid_height for i in range((height//inner_grid_height))]

    print(hor_patch)
    print(ver_patch)

    for i,row in enumerate(hor_patch):
        for j,column in enumerate(ver_patch):

            x_scalar,y_scalar = row,column
            x_temp,y_temp =  row,column

            x_scalar,y_scalar = x_scalar+inner_grid_width,y_scalar
            x_temp,y_temp = np.append(x_temp,x_scalar),np.append(y_temp,y_scalar)

            x_scalar,y_scalar = x_scalar,y_scalar+inner_grid_height
            x_temp,y_temp = np.append(x_temp,x_scalar),np.append(y_temp,y_scalar)

            x_scalar,y_scalar = x_scalar-inner_grid_width,y_scalar
            x_temp,y_temp = np.append(x_temp,x_scalar),np.append(y_temp,y_scalar)

            x_scalar,y_scalar = x_scalar,y_scalar-inner_grid_height
            x_temp,y_temp = np.append(x_temp,x_scalar),np.append(y_temp,y_scalar)

            string = ("({},{})".format(row+(inner_grid_width//2),column+(inner_grid_height//2)))
            x_cen,y_cen = row+(inner_grid_width/2),column+(inner_grid_height/2)

            x_center,y_center = np.append(x_center,x_cen),np.append(y_center,y_cen)

            plt.plot(x_temp,y_temp,color='black')
        
    plt.scatter(x_center,y_center,c='green',s=10)

    rectangular_hilbert_curves = get_space_fill_graph(x_center[0],y_center[0],x_center[-1],y_center[-1],inner_grid_height,inner_grid_width)

    return [x_center,y_center], rectangular_hilbert_curves

#!/usr/bin/env python3
# SPDX-License-Identifier: BSD-2-Clause
# Copyright (c) 2018 Jakub Červený

def gilbert2d(width, height):
    """
    Generalized Hilbert ('gilbert') space-filling curve for arbitrary-sized
    2D rectangular grids. Generates discrete 2D coordinates to fill a rectangle
    of size (width x height).
    """

    if width >= height:
        yield from generate2d(0, 0, width, 0, 0, height)
    else:
        yield from generate2d(0, 0, 0, height, width, 0)

def sgn(x):
    return -1 if x < 0 else (1 if x > 0 else 0)

def generate2d(x, y, ax, ay, bx, by):

    w = abs(ax + ay)
    h = abs(bx + by)

    #print("this is w",w)

    (dax, day) = (sgn(ax), sgn(ay)) # unit major direction
    (dbx, dby) = (sgn(bx), sgn(by)) # unit orthogonal direction

    if h == 1:
        # trivial row fill
        for i in range(0, int(w)):
            yield(x, y)
            (x, y) = (x + dax, y + day)
        return

    if w == 1:
        # trivial column fill
        for i in range(0, int(h)):
            yield(x, y)
            (x, y) = (x + dbx, y + dby)
        return

    (ax2, ay2) = (ax//2, ay//2)
    (bx2, by2) = (bx//2, by//2)

    w2 = abs(ax2 + ay2)
    h2 = abs(bx2 + by2)

    if 2*w > 3*h:
        if (w2 % 2) and (w > 2):
            # prefer even steps
            (ax2, ay2) = (ax2 + dax, ay2 + day)

        # long case: split in two parts only
        yield from generate2d(x, y, ax2, ay2, bx, by)
        yield from generate2d(x+ax2, y+ay2, ax-ax2, ay-ay2, bx, by)

    else:
        if (h2 % 2) and (h > 2):
            # prefer even steps
            (bx2, by2) = (bx2 + dbx, by2 + dby)

        # standard case: one step up, one long horizontal, one step down
        yield from generate2d(x, y, bx2, by2, ax2, ay2)
        yield from generate2d(x+bx2, y+by2, ax, ay, bx-bx2, by-by2)
        yield from generate2d(x+(ax-dax)+(bx2-dbx), y+(ay-day)+(by2-dby),
                              -bx2, -by2, -(ax-ax2), -(ay-ay2))

def get_space_fill_graph(x1,y1,x2,y2,inner_grid_height,inner_grid_width):
    height = (abs(y2-y1)//inner_grid_height) + 1
    width = (abs(x2-x1)//inner_grid_width) + 1

    print("height : ",height)
    print("weight : ",width)

    x_arr = [ x*inner_grid_width for x, y in gilbert2d(width, height)]
    y_arr = [ y*inner_grid_height for x, y in gilbert2d(width, height)]

    x,y = x_arr + x1,y_arr + y1 

    plt.plot(x,y,color='red',linewidth = 2)

    return [x,y]

if __name__ == "__main__":
    height = 120
    width = 120

    inner_grid_width = 15
    inner_grid_height = 10

    DG1, DG2, RHC1, RHC2 = plot_main_figure(height,width,inner_grid_height,inner_grid_width)
    
    k_max = len(DG1[0]) + len(DG2[0])
    time = []
    optimal_k = []
    for t in range(1,k_max+1):
        optimal_searcher = []
        for k in range(k_max,0,-1):
            if (len(DG1[0])+len(DG2[0]))/k - t == 0.0:
                optimal_searcher.append(k)

        if len(optimal_searcher)!=0:
            time.append(t)
            optimal_k.append(min(optimal_searcher))

            

    plt.plot(time,optimal_k)
    plt.show()





